<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <video id="video" crossorigin="anonymous" src="https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerMeltdowns.mp4" height="100" controls></video>

    <div id="here"></div>

    <canvas id="canvas" style="display: none;"></canvas>
    
    <script>
        const id = Math.round(Math.random() * 10000);
        window.document.title = id;
        const here = {};
        const hereEl = document.getElementById('here');
        const broadcast = new BroadcastChannel('default');
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 100;
        canvas.height = 100;
        //

        function setupWebRTC(key) {
            here[key].peerConnection = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });
            here[key].peerConnection.addEventListener('icecandidate', event => event.candidate && broadcast.postMessage({ from: id, to: key, type: 'ice-candidate', content: { candidate: JSON.parse(JSON.stringify(event.candidate)) } }));
            here[key].channel = here[key].peerConnection.createDataChannel("chat", { negotiated: true, id: 0 });
            here[key].channel.onmessage = (event) => here[key].lastMessageReceived = { at: Date.now(), data: event.data };
            here[key].lastMessageReceived = {};
        }

        function receiveHere(inHere) {
            if (!here[inHere]) {
                here[inHere] = { firstHearbeat: Date.now() };
            }
            here[inHere].lastHeartbeat = Date.now();
        }
        setInterval(() => {
            Object.keys(here).forEach(inHere => {
                if ((here[inHere].lastHeartbeat + 10_000) < Date.now()) {
                    delete here[inHere];
                }
            })
        }, 500);

        setInterval(() => {
            Object.keys(here).forEach(inHere => {
                const div = hereEl.querySelector('#id-' + inHere) || document.createElement('div');
                div.id = 'id-' + inHere;

                const span = div.querySelector('span') || document.createElement('span');
                span.innerText = `${inHere} (${new Date(here[inHere].lastHeartbeat).toLocaleTimeString()})`;
                if (!div.contains(span)) div.appendChild(span);

                const button = div.querySelector('button') || document.createElement('button');
                if (!here[inHere].peerConnection) {
                    button.onclick = async () => {
                        setupWebRTC(inHere);

                        const sdp = await here[inHere].peerConnection.createOffer();
                        here[inHere].peerConnection.setLocalDescription(sdp);
                        broadcast.postMessage({ from: id, to: inHere, type: 'connect', content: { sdp } });
                    }
                    button.innerText = 'Connect'
                } else {
                    button.onclick = () => {
                        // TODO: disconnect
                    };
                    button.innerText = `${here[inHere].peerConnection.connectionState} ${here[inHere].channel.readyState}`;
                }
                if (!div.contains(button)) div.appendChild(button);

                if (here[inHere].lastMessageReceived?.data) {
                    const lastMessage = div.querySelector('div') || document.createElement('div');
                    const image = lastMessage.querySelector('img') || document.createElement('img');
                    image.src = URL.createObjectURL(new Blob([here[inHere].lastMessageReceived.data]))
                    if (!lastMessage.contains(image)) lastMessage.appendChild(image);
                    if (!div.contains(lastMessage)) div.appendChild(lastMessage);
                }

                if (!hereEl.contains(div)) hereEl.append(div);
            });
        });

        broadcast.onmessage = async event => {
            if (event.data.to === 'all') {
                if (event.data.type === 'hi') {
                    broadcast.postMessage({ from: id, to: event.data.from, type: 'hello' });
                    receiveHere(event.data.from);
                }
                if (event.data.type === 'keepalive') {
                    receiveHere(event.data.from);
                }
            }
            if (event.data.to == id) {
                if (event.data.type === 'hello') {
                    receiveHere(event.data.from);
                } else if (event.data.type === 'connect') {
                    setupWebRTC(event.data.from);

                    here[event.data.from].peerConnection.setRemoteDescription(event.data.content.sdp);
                    const sdp = await here[event.data.from].peerConnection.createAnswer();
                    here[event.data.from].peerConnection.setLocalDescription(sdp);

                    broadcast.postMessage({ from: id, to: event.data.from, type: 'answer-connect', content: { sdp } });
                } else if (event.data.type === 'answer-connect') {
                    here[event.data.from].peerConnection.setRemoteDescription(event.data.content.sdp);
                } else if (event.data.type === 'ice-candidate') {
                    here[event.data.from].peerConnection.addIceCandidate(new RTCIceCandidate(event.data.content.candidate));
                }
            }
        };
        broadcast.postMessage({ from: id, to: 'all', type: 'hi' });
        setInterval(() => broadcast.postMessage({ from: id, to: 'all', type: 'keepalive' }), 1000);

        //
        
        let interval = null;
        video.onplay = event => {
            clearInterval(interval);
            interval = setInterval(() => {
                Object.keys(here).forEach(inHere => {
                    if (here[inHere].peerConnection?.connectionState === 'connected' && here[inHere].channel.readyState == 'open') {
                        context.drawImage(video, 0, 0, 100, 100);
                        canvas.toBlob(async blob => {
                            const buffer = await blob.arrayBuffer();
                            here[inHere].channel.send(buffer)
                        });
                    }
                })
            })
        }
    </script>
    
</body>
</html>