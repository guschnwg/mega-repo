<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <video id="video" crossorigin="anonymous"
        src="https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerMeltdowns.mp4" height="100" controls loop
        preload="auto"></video>

    <div v-scope @vue:mounted="mounted">
        <h1>Open the DevTools to prevent the suppression of the prompt</h1>

        <h1>{{ id }} - {{ clientsRTCMapKey }}</h1>

        <li v-for="client in clients">
            {{ client }}

            <div v-if="Object.keys(clientsRTCMap).includes(client)" @class="clientsRTCMap[client].lastPing" style="display: inline;">
                <span v-if="clientsRTCMap[client]?.lastMessageReceived?.data">
                    Last message: {{ clientsRTCMap[client].lastMessageReceived.data }}
                </span>

                <!-- clientsRTCMapKey in the template is used to force the reactivity of the buttons -->
                <span v-if="clientsRTCMapKey && isActive(client)">
                    <button @click="sendMessage(client)">
                        Send message
                    </button>
                </span>
                <span v-else-if="clientsRTCMapKey && isPendingAnswering(client)">
                    <button @click="sendAnswer(client)">
                        Accept call {{ clientsRTCMapKey }}
                    </button>
                </span>
                <button v-else-if="clientsRTCMapKey && isPendingBeingAnswered(client)" disabled>
                    Waiting for answer {{ clientsRTCMapKey }}
                </button>
                <button v-else disabled :title="clientsRTCMap[client]?.peerConnection.signalingState + ' - ' + clientsRTCMap[client]?.peerConnection.connectionState + ' - ' + clientsRTCMap[client]?.channel.readyState">
                    Something else........
                </button>

                <video :id="'video-for-' + client" height="100" v-if="clientsRTCMap[client]?.tracks.length"
                    crossorigin="anonymous"></video>
                <button @click="$event.target.previousElementSibling.play(); $event.target.remove()">Receive
                    video</button>
            </div>
            <div v-else style="display: inline;">
                <button @click="sendOffer(client)">Call</button>
            </div>
        </li>
    </div>

    <script type="module">
        import { createApp } from 'https://unpkg.com/petite-vue?module'

        createApp({
            id: null,
            clients: [],
            clientsRTCMap: {},
            clientsRTCMapKey: 1,
            socket: new WebSocket("ws://localhost:8080/ws"),
            mounted() {
                setInterval(() => {
                    this.socket.send(JSON.stringify({ type: 'ping' }));

                    Object.keys(this.clientsRTCMap).forEach(client => {
                        const { peerConnection, channel } = this.clientsRTCMap[client];
                        if (channel.readyState === 'open') {
                            this.clientsRTCMap[client].lastPing = Date.now();
                        }
                        // if (Date.now() - this.clientsRTCMap[client].lastPing > 5000) {
                        //     peerConnection.close();
                        //     delete this.clientsRTCMap[client];
                        // }
                    });
                }, 1000);

                this.socket.addEventListener('message', message => {
                    const data = JSON.parse(message.data);

                    if (data.type === 'welcome') {
                        this.id = data.id;
                    } else if (data.type === 'refresh') {
                        this.clients = data.clients.filter(c => c !== this.id);
                    } else if (data.type === 'offer') {
                        this.receiveOffer(data.from, data.offer);
                    } else if (data.type === 'answer') {
                        this.receiveAnswer(data.from, data.answer);
                    } else if (data.type === 'candidate') {
                        this.receiveIceCandidade(data.from, data.candidate);
                    }
                })
            },
            bumpKey() {
                this.clientsRTCMapKey++;
            },
            //
            createPeerConnection(client) {
                const peerConnection = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });
                const channel = peerConnection.createDataChannel("chat", { negotiated: true, id: 0 });

                // SHITTY
                channel.addEventListener('open', this.bumpKey);
                peerConnection.addEventListener('signalingstatechange', this.bumpKey);
                peerConnection.addEventListener('connectionstatechange', this.bumpKey);

                this.clientsRTCMap[client] = {
                    peerConnection,
                    channel,
                    lastPing: Date.now(),
                    lastMessageReceived: {},
                    tracks: []
                };

                peerConnection.addEventListener("icecandidate", (event) => {
                    if (!event.candidate) return;
                    this.socket.send(JSON.stringify({ type: "candidate", to: client, candidate: event.candidate }));
                });
                peerConnection.addEventListener('track', event => {
                    this.clientsRTCMap[client].tracks.push(event.track);
                    const video = document.getElementById('video-for-' + client);
                    if (video) video.srcObject = new MediaStream(this.clientsRTCMap[client].tracks);
                });
                channel.addEventListener('message', event => {
                    this.clientsRTCMap[client].lastMessageReceived = { at: Date.now(), data: event.data };
                });

                return this.clientsRTCMap[client];
            },
            //
            sendOffer(to) {
                const { peerConnection } = this.createPeerConnection(to);

                if (document.getElementById('video').captureStream) {
                    peerConnection.addStream(document.getElementById('video').captureStream());
                }
                peerConnection
                    .createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true })
                    .then(sdp => {
                        peerConnection.setLocalDescription(sdp);

                        this.socket.send(JSON.stringify({ type: "offer", to, offer: sdp }));
                    });
            },
            receiveOffer(from, offer) {
                const { peerConnection } = this.createPeerConnection(from);
                peerConnection.setRemoteDescription(offer).then(() => {});
            },
            sendAnswer(to) {
                const { peerConnection } = this.clientsRTCMap[to];

                peerConnection
                    .createAnswer({ offerToReceiveVideo: true, offerToReceiveAudio: true })
                    .then(localSdp => {
                        peerConnection.setLocalDescription(localSdp);
                        this.socket.send(JSON.stringify({ type: "answer", to, answer: localSdp }));
                    });
            },
            receiveAnswer(from, answer) {
                const { peerConnection } = this.clientsRTCMap[from];

                peerConnection.setRemoteDescription(answer);
            },
            receiveIceCandidade(from, candidate) {
                const { peerConnection, channel } = this.clientsRTCMap[from];

                peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            },
            //
            isActive(client) {
                return this.clientsRTCMap[client]?.channel.readyState === 'open';
            },
            isPendingBeingAnswered(client) {
                return this.clientsRTCMap[client]?.peerConnection.signalingState === 'have-local-offer';
            },
            isPendingAnswering(client) {
                return this.clientsRTCMap[client]?.peerConnection.signalingState === 'have-remote-offer';
            },
            sendMessage(to) {
                const { channel } = this.clientsRTCMap[to];
                channel.send(prompt('Send:', 'nothing'));
            },
        }).mount()
    </script>
</body>

</html>