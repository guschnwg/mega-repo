<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>

    <style>
        .client {
            display: flex;
            height: 50px;
            align-items: center;
            justify-content: space-between;
            border: 1px solid red;

            padding: 5px;
        }

        .info {
            display: flex;
            flex-direction: column;
            justify-content: space-evenly;
        }

        .client video {
            vertical-align: middle;
        }

        .clients {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
    </style>
</head>

<body>
    <div v-scope @vue:mounted="mounted">
        <div class="my-video">
            <div class="choose-video">
                <span>Change the video file</span>
                <input type="file" id="file" accept="video/*" @change="fileSelected">
            </div>

            <video id="video" crossorigin="anonymous"
                src="https://storage.googleapis.com/gtv-videos-bucket/sample/ForBiggerMeltdowns.mp4" height="100" controls loop
                preload="auto"></video>
        </div>

        <h1>I am: {{ id }}</h1>

        <h2>Clients:</h2>
        <div class="clients">
            <div v-for="client in clients" class="client">
                <div class="info">
                    <span :title="clientsRTCMap[client]?.lastPing">{{ client }}</span>

                    <span v-if="clientsRTCMap[client]?.lastMessageReceived?.data">
                        Last message: {{ clientsRTCMap[client].lastMessageReceived.data }}
                    </span>
                </div>

                <video
                    v-if="clientsRTCMapKey && clientsRTCMap[client]?.tracks.length"
                    :id="'video-for-' + client"
                    :style="hasClient(client) && isActive(client) ? 'display: 'block;' 'display: none;'"
                    height="50"
                    crossorigin="anonymous"></video>

                <!-- clientsRTCMapKey in the template is used to force the reactivity of the buttons -->
                <div v-if="clientsRTCMapKey && !hasClient(client)">
                    <button @click="sendOffer(client)">Call</button>
                </div>
                <div v-else>
                    <button v-if="clientsRTCMapKey && isPendingAnswering(client)" @click="sendAnswer(client)">
                        Accept call?
                    </button>

                    <button v-else-if="clientsRTCMapKey && isPendingBeingAnswered(client)" disabled>
                        Ringing...
                    </button>

                    <button v-else-if="clientsRTCMapKey && isActive(client)" @click="sendMessage(client)">
                        Send message
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        import { createApp } from 'https://unpkg.com/petite-vue?module'

        createApp({
            id: null,
            clients: [],
            clientsRTCMap: {},
            clientsRTCMapKey: 1,
            socket: new WebSocket("ws://localhost:8080/ws"),
            mounted() {
                setInterval(() => {
                    this.socket.send(JSON.stringify({ type: 'ping' }));

                    Object.keys(this.clientsRTCMap).forEach(client => {
                        const { peerConnection, channel } = this.clientsRTCMap[client];
                        if (channel.readyState === 'open') {
                            this.clientsRTCMap[client].lastPing = Date.now();
                        }
                        // if (Date.now() - this.clientsRTCMap[client].lastPing > 5000) {
                        //     peerConnection.close();
                        //     delete this.clientsRTCMap[client];
                        // }
                    });
                }, 1000);

                this.socket.addEventListener('message', message => {
                    const data = JSON.parse(message.data);

                    if (data.type === 'welcome') {
                        this.id = data.id;
                    } else if (data.type === 'refresh') {
                        this.clients = data.clients.filter(c => c !== this.id);
                    } else if (data.type === 'offer') {
                        this.receiveOffer(data.from, data.offer);
                    } else if (data.type === 'answer') {
                        this.receiveAnswer(data.from, data.answer);
                    } else if (data.type === 'candidate') {
                        this.receiveIceCandidade(data.from, data.candidate);
                    }
                })
            },
            bumpKey() {
                this.clientsRTCMapKey++;
            },
            //
            createPeerConnection(client) {
                const peerConnection = new RTCPeerConnection({ iceServers: [{ urls: "stun:stun.l.google.com:19302" }] });
                const channel = peerConnection.createDataChannel("chat", { negotiated: true, id: 0 });

                // SHITTY
                channel.addEventListener('open', this.bumpKey);
                peerConnection.addEventListener('signalingstatechange', this.bumpKey);
                peerConnection.addEventListener('connectionstatechange', event => {
                    if (event.target.connectionState === 'connected') {
                        const video = document.getElementById('video-for-' + client);
                        if (video) video.play();
                    }

                    this.bumpKey();
                });

                this.clientsRTCMap[client] = {
                    peerConnection,
                    channel,
                    lastPing: Date.now(),
                    lastMessageReceived: {},
                    tracks: []
                };

                peerConnection.addEventListener("icecandidate", (event) => {
                    if (!event.candidate) return;
                    this.socket.send(JSON.stringify({ type: "candidate", to: client, candidate: event.candidate }));
                });
                peerConnection.addEventListener('track', event => {
                    this.clientsRTCMap[client].tracks.push(event.track);
                    const video = document.getElementById('video-for-' + client);
                    const stream = new MediaStream(this.clientsRTCMap[client].tracks);
                    if (video) video.srcObject = stream;
                });
                channel.addEventListener('message', event => {
                    this.clientsRTCMap[client].lastMessageReceived = { at: Date.now(), data: event.data };
                });

                if (document.getElementById('video').captureStream) {
                    peerConnection.addStream(document.getElementById('video').captureStream());
                }

                return this.clientsRTCMap[client];
            },
            //
            sendOffer(to) {
                const { peerConnection } = this.createPeerConnection(to);

                peerConnection
                    .createOffer({ offerToReceiveAudio: true, offerToReceiveVideo: true })
                    .then(sdp => {
                        peerConnection.setLocalDescription(sdp);

                        this.socket.send(JSON.stringify({ type: "offer", to, offer: sdp }));
                    });
            },
            receiveOffer(from, offer) {
                const { peerConnection } = this.createPeerConnection(from);

                peerConnection.setRemoteDescription(offer).then(() => {});
            },
            sendAnswer(to) {
                const { peerConnection } = this.clientsRTCMap[to];

                peerConnection
                    .createAnswer({ offerToReceiveVideo: true, offerToReceiveAudio: true })
                    .then(localSdp => {
                        peerConnection.setLocalDescription(localSdp);
                        this.socket.send(JSON.stringify({ type: "answer", to, answer: localSdp }));
                    });
            },
            receiveAnswer(from, answer) {
                const { peerConnection } = this.clientsRTCMap[from];

                peerConnection.setRemoteDescription(answer);
            },
            receiveIceCandidade(from, candidate) {
                const { peerConnection, channel } = this.clientsRTCMap[from];

                peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            },
            //
            hasClient(client) {
                return Object.keys(this.clientsRTCMap).includes(client);
            },
            isActive(client) {
                return this.clientsRTCMap[client]?.channel.readyState === 'open';
            },
            isPendingBeingAnswered(client) {
                return this.clientsRTCMap[client]?.peerConnection.signalingState === 'have-local-offer';
            },
            isPendingAnswering(client) {
                return this.clientsRTCMap[client]?.peerConnection.signalingState === 'have-remote-offer';
            },
            //
            sendMessage(to) {
                const { channel } = this.clientsRTCMap[to];
                channel.send(prompt('Send:', 'nothing'));
            },
            fileSelected(event) {
                const file = event.target.files[0];
                const video = document.getElementById('video');
                video.src = URL.createObjectURL(file);
            },
        }).mount()
    </script>
</body>

</html>