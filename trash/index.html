<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <canvas height=500 width=500></canvas>

    <div id="destination"></div>
    <div id="mouse"></div>

    <script>
        const canvas = document.getElementsByTagName('canvas')[0];
        const ctx = canvas.getContext("2d");

        const destinationEl = document.getElementById('destination');
        const mouseEl = document.getElementById('mouse');

        const world = [
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 1, 1, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 1, 1, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
        ];

        const player = {
            x: 1.5,
            y: 3,
        }

        const mouse = {
            x: 0,
            y: 0,
        }

        const destination = {
            x: 4,
            y: 1,
        }

        canvas.addEventListener('mousemove', e => {
            const rect = e.target.getBoundingClientRect();
            mouse.x = (e.clientX - rect.left) / 50; //x position within the element.
            mouse.y = (e.clientY - rect.top) / 50;  //y position within the element.
        })

        canvas.addEventListener('mousedown', e => {
            const rect = e.target.getBoundingClientRect();
            destination.x = Math.floor((e.clientX - rect.left) / 50); //x position within the element.
            destination.y = Math.floor((e.clientY - rect.top) / 50);  //y position within the element.
        })

        window.addEventListener('keydown', e => {
            if (e.key === 'w') {
                player.y -= 0.1;
            } else if (e.key === 's') {
                player.y += 0.1;
            } else if (e.key === 'a') {
                player.x -= 0.1;
            } else if (e.key === 'd') {
                player.x += 0.1;
            }
        })

        function draw() {
            // World
            world.forEach((row, rIndex) => {
                row.forEach((column, cIndex) => {
                    if (column == 0) {
                        ctx.fillStyle = 'black';
                    } else {
                        ctx.fillStyle = 'red';
                    }
                    ctx.fillRect(50 * cIndex, 50 * rIndex, 50, 50);
                    ctx.strokeStyle = 'lightgray';
                    ctx.strokeRect(50 * cIndex, 50 * rIndex, 50, 50);
                });
            });

            // Player
            ctx.beginPath()
            ctx.arc(player.x * 50, player.y * 50, 5, 0, 2 * Math.PI, false);
            ctx.fillStyle = 'blue';
            ctx.fill();

            // Line
            ctx.beginPath();
            ctx.strokeStyle = 'purple';
            ctx.moveTo(player.x * 50, player.y * 50);
            ctx.lineTo(mouse.x * 50, mouse.y * 50);
            ctx.stroke();

            // Destination
            ctx.beginPath();
            ctx.strokeStyle = 'yellow';
            ctx.moveTo(player.x * 50, player.y * 50);
            ctx.lineTo(destination.x * 50, destination.y * 50);
            ctx.stroke();

            info('Destination', destinationEl, player, destination);
            info('Mouse', mouseEl, player, mouse);

            setTimeout(draw, 1000 / 60);
        }

        function getAngle(first, second) {
            const angle = Math.atan2(second.y - first.y, second.x - first.x);
            return angle < 0 ? angle + 2 * Math.PI : angle;
        }

        function toDeg(inRad) {
            return inRad * (180 / Math.PI);
        }

        function isInWorld(x, y) {
            return y >= 0 && y < world.length && x >= 0 && x < world[y].length;
        }

        function isWall(x, y) {
            return world[y][x] != 0;
        }

        function ray(from, angle) {
            const angleCos = Math.cos(angle)
            const angleSin = Math.sin(angle)

            const oneUnitInX = 1 / angleCos;
            const oneUnitInY = 1 / angleSin;

            const xDirection = angleCos > 0 ? 1 : -1;
            const yDirection = angleSin > 0 ? 1 : -1;

            let firstUnitInX = oneUnitInX;
            if (Math.floor(from.x) != from.x) {
                if (xDirection > 0) {
                    firstUnitInX = (Math.ceil(from.x) - from.x) / angleCos;
                } else {
                    firstUnitInX = (Math.floor(from.x) - from.x) / angleCos;
                }
            }
            let firstUnitInY = oneUnitInY;
            if (Math.floor(from.y) != from.y) {
                if (yDirection > 0) {
                    firstUnitInY = (Math.ceil(from.y) - from.y) / angleSin;
                } else {
                    firstUnitInY = (Math.floor(from.y) - from.y) / angleSin;
                }
            }

            let remainerInX = Math.abs(firstUnitInX);
            let remainerInY = Math.abs(firstUnitInY);

            let currentX = from.x;
            let currentY = from.y;

            const increments = [];
            for (let i = 0; i < 20; i++) {
                let increment = 0;
                let incrementX = 0;
                let incrementY = 0;

                if (remainerInX < remainerInY) {
                    remainerInY -= remainerInX;

                    incrementX = remainerInX * angleCos;
                    incrementY = remainerInX * angleSin;

                    increment = remainerInX;
                    remainerInX = Math.abs(oneUnitInX);
                } else if (remainerInX > remainerInY) {
                    remainerInX -= remainerInY;

                    incrementX = remainerInY * angleCos;
                    incrementY = remainerInY * angleSin;

                    increment = remainerInY;
                    remainerInY = Math.abs(oneUnitInY);
                } else {
                    incrementX = remainerInX * angleCos;
                    incrementY = remainerInX * angleSin;

                    increment = remainerInX;
                    remainerInX = Math.abs(oneUnitInX);
                    remainerInY = Math.abs(oneUnitInY);
                }

                // The checker
                let positionX = currentX + ((currentX + incrementX) - currentX) / 2;
                let positionY = currentY + ((currentY + incrementY) - currentY) / 2;
                ctx.beginPath()
                ctx.arc(positionX * 50, positionY * 50, 2, 0, 2 * Math.PI, false);
                ctx.fillStyle = 'yellow';
                ctx.fill();

                if (!isInWorld(Math.floor(positionX), Math.floor(positionY)) || isWall(Math.floor(positionX), Math.floor(positionY))) {
                    ctx.beginPath()
                    ctx.arc(currentX * 50, currentY * 50, 4, 0, 2 * Math.PI, false);
                    ctx.fillStyle = 'red';
                    ctx.fill();

                    break;
                }

                increments.push(increment);
                currentX += incrementX;
                currentY += incrementY;

                // Debug add dot to the collisions
                ctx.beginPath()
                ctx.arc(currentX * 50, currentY * 50, 4, 0, 2 * Math.PI, false);
                ctx.fillStyle = 'green';
                ctx.fill();
                // End debug
            }

            const distance = increments.reduce((acc, i) => acc + i, 0);

            return {
                distance,
                oneUnitInX,
                oneUnitInY,
                xDirection,
                yDirection,
                increments
            }
        }

        function info(title, el, from, to) {
            const angleRad = getAngle(from, to)
            const angleDeg = toDeg(angleRad)

            const {
                distance,
                oneUnitInX,
                oneUnitInY,
                xDirection,
                yDirection,
                increments
            } = ray(from, angleRad);

            el.innerHTML = `
                <h4>${title}: </h4>
                Distance: ${distance}
                <br />
                Angle: ${angleDeg}
                <br />
                One unit in X: ${oneUnitInX}
                <br />
                One unit in Y: ${oneUnitInY}
                <br />
                Direction in X: ${xDirection}
                <br />
                Direction in Y: ${yDirection}
                <br />
                Increments: ${increments.map(i => i.toFixed(2)).join(', ')}
                <br />
                Len: ${increments.reduce((acc, i) => acc + i, 0).toFixed(2)}
            `;
        }

        draw();

    </script>
</body>

</html>