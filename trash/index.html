<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div style="display: inline; overflow: scroll; white-space: nowrap;">
        <canvas id="world" height=500 width=500></canvas>

        <canvas id="camera" height=600 width=800></canvas>
    </div>

    <div id="destination"></div>
    <div id="mouse"></div>

    <script>
        const worldCanvas = document.getElementById('world');
        const worldCtx = worldCanvas.getContext("2d");

        const cameraCanvas = document.getElementById('camera');
        const cameraCtx = cameraCanvas.getContext("2d");

        const destinationEl = document.getElementById('destination');
        const mouseEl = document.getElementById('mouse');

        const world = [
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 1, 1, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            [0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
            [0, 0, 1, 1, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
            [0, 0, 0, 1, 0, 0, 1, 0, 0, 0],
        ];

        const player = {
            x: 1.5,
            y: 3,
        }

        const mouse = {
            x: 0,
            y: 0,
        }

        const destination = {
            x: 4,
            y: 1,
        }

        worldCanvas.addEventListener('mousemove', e => {
            const rect = e.target.getBoundingClientRect();
            mouse.x = (e.clientX - rect.left) / 50; //x position within the element.
            mouse.y = (e.clientY - rect.top) / 50;  //y position within the element.
        })

        worldCanvas.addEventListener('mousedown', e => {
            const rect = e.target.getBoundingClientRect();
            destination.x = Math.floor((e.clientX - rect.left) / 50); //x position within the element.
            destination.y = Math.floor((e.clientY - rect.top) / 50);  //y position within the element.
        })

        window.addEventListener('keydown', e => {
            if (e.key === 'w') {
                player.y -= 0.1;
            } else if (e.key === 's') {
                player.y += 0.1;
            } else if (e.key === 'a') {
                player.x -= 0.1;
            } else if (e.key === 'd') {
                player.x += 0.1;
            }
        })

        function draw() {
            // World
            world.forEach((row, rIndex) => {
                row.forEach((column, cIndex) => {
                    if (column == 0) {
                        worldCtx.fillStyle = 'black';
                    } else {
                        worldCtx.fillStyle = 'red';
                    }
                    worldCtx.fillRect(50 * cIndex, 50 * rIndex, 50, 50);
                    worldCtx.strokeStyle = 'lightgray';
                    worldCtx.strokeRect(50 * cIndex, 50 * rIndex, 50, 50);
                });
            });

            // Player
            worldCtx.beginPath()
            worldCtx.arc(player.x * 50, player.y * 50, 5, 0, 2 * Math.PI, false);
            worldCtx.fillStyle = 'blue';
            worldCtx.fill();

            // Line
            worldCtx.beginPath();
            worldCtx.strokeStyle = 'purple';
            worldCtx.moveTo(player.x * 50, player.y * 50);
            worldCtx.lineTo(mouse.x * 50, mouse.y * 50);
            worldCtx.stroke();

            // Destination
            worldCtx.beginPath();
            worldCtx.strokeStyle = 'yellow';
            worldCtx.moveTo(player.x * 50, player.y * 50);
            worldCtx.lineTo(destination.x * 50, destination.y * 50);
            worldCtx.stroke();

            info('Destination', destinationEl, player, destination);
            info('Mouse', mouseEl, player, mouse);

            // Camera
            cameraCtx.clearRect(0, 0, cameraCanvas.width, cameraCanvas.height);
            cameraCtx.fillStyle = 'darkblue';
            cameraCtx.fillRect(0, 0, cameraCanvas.width, cameraCanvas.height / 2);
            cameraCtx.fillStyle = 'peru';
            cameraCtx.fillRect(0, cameraCanvas.height / 2, cameraCanvas.width, cameraCanvas.height / 2);

            pov(player, mouse);

            setTimeout(draw, 1000 / 60);
        }

        function getAngle(first, second) {
            const angle = Math.atan2(second.y - first.y, second.x - first.x);
            return angle < 0 ? angle + 2 * Math.PI : angle;
        }

        function toDeg(inRad) {
            return inRad * (180 / Math.PI);
        }

        function isInWorld(x, y) {
            return y >= 0 && y < world.length && x >= 0 && x < world[y].length;
        }

        function isWall(x, y) {
            return world[y][x] != 0;
        }

        function ray(from, angle) {
            const angleCos = Math.cos(angle)
            const angleSin = Math.sin(angle)

            const oneUnitInX = 1 / angleCos;
            const oneUnitInY = 1 / angleSin;

            const xDirection = angleCos > 0 ? 1 : -1;
            const yDirection = angleSin > 0 ? 1 : -1;

            let firstUnitInX = oneUnitInX;
            if (Math.floor(from.x) != from.x) {
                if (xDirection > 0) {
                    firstUnitInX = (Math.ceil(from.x) - from.x) / angleCos;
                } else {
                    firstUnitInX = (Math.floor(from.x) - from.x) / angleCos;
                }
            }
            let firstUnitInY = oneUnitInY;
            if (Math.floor(from.y) != from.y) {
                if (yDirection > 0) {
                    firstUnitInY = (Math.ceil(from.y) - from.y) / angleSin;
                } else {
                    firstUnitInY = (Math.floor(from.y) - from.y) / angleSin;
                }
            }

            let remainerInX = Math.abs(firstUnitInX);
            let remainerInY = Math.abs(firstUnitInY);

            let currentX = from.x;
            let currentY = from.y;

            let lastSideHit = 0;

            const increments = [];
            for (let i = 0; i < 20; i++) {
                let increment = 0;
                let incrementX = 0;
                let incrementY = 0;
                let currentSideHit = 0;

                if (remainerInX < remainerInY) {
                    remainerInY -= remainerInX;

                    incrementX = remainerInX * angleCos;
                    incrementY = remainerInX * angleSin;

                    increment = remainerInX;
                    remainerInX = Math.abs(oneUnitInX);
                    currentSideHit = 0;
                } else if (remainerInX > remainerInY) {
                    remainerInX -= remainerInY;

                    incrementX = remainerInY * angleCos;
                    incrementY = remainerInY * angleSin;

                    increment = remainerInY;
                    remainerInY = Math.abs(oneUnitInY);
                    currentSideHit = 1;
                } else {
                    incrementX = remainerInX * angleCos;
                    incrementY = remainerInX * angleSin;

                    increment = remainerInX;
                    remainerInX = Math.abs(oneUnitInX);
                    remainerInY = Math.abs(oneUnitInY);
                    currentSideHit = 2;
                }

                // The checker
                let positionX = currentX + ((currentX + incrementX) - currentX) / 2;
                let positionY = currentY + ((currentY + incrementY) - currentY) / 2;
                worldCtx.beginPath()
                worldCtx.arc(positionX * 50, positionY * 50, 2, 0, 2 * Math.PI, false);
                worldCtx.fillStyle = 'yellow';
                worldCtx.fill();

                if (!isInWorld(Math.floor(positionX), Math.floor(positionY)) || isWall(Math.floor(positionX), Math.floor(positionY))) {
                    worldCtx.beginPath()
                    worldCtx.arc(currentX * 50, currentY * 50, 4, 0, 2 * Math.PI, false);
                    worldCtx.fillStyle = 'red';
                    worldCtx.fill();

                    break;
                }

                increments.push(increment);
                currentX += incrementX;
                currentY += incrementY;
                lastSideHit = currentSideHit;

                // Debug add dot to the collisions
                worldCtx.beginPath()
                worldCtx.arc(currentX * 50, currentY * 50, 4, 0, 2 * Math.PI, false);
                worldCtx.fillStyle = 'green';
                worldCtx.fill();
                // End debug
            }

            const distance = increments.reduce((acc, i) => acc + i, 0);

            return {
                distance,
                oneUnitInX,
                oneUnitInY,
                xDirection,
                yDirection,
                increments,
                lastSideHit,
            }
        }

        function info(title, el, from, to) {
            const angleRad = getAngle(from, to)
            const angleDeg = toDeg(angleRad)

            const {
                distance,
                oneUnitInX,
                oneUnitInY,
                xDirection,
                yDirection,
                increments,
                lastSideHit
            } = ray(from, angleRad);

            el.innerHTML = `
                <h4>${title}: </h4>
                Distance: ${distance}
                <br />
                Angle: ${angleDeg}
                <br />
                One unit in X: ${oneUnitInX}
                <br />
                One unit in Y: ${oneUnitInY}
                <br />
                Direction in X: ${xDirection}
                <br />
                Direction in Y: ${yDirection}
                <br />
                Increments: ${increments.map(i => i.toFixed(2)).join(', ')}
                <br />
                Len: ${increments.reduce((acc, i) => acc + i, 0).toFixed(2)}
                <br />
                Last side hit: ${lastSideHit}
            `;
        }

        function invertScale(input, min, max) {
            return max + min - input;
        }

        function convertValue(fromScale, toScale, value) {
            const converted = toScale.min - ((fromScale.min - value) / fromScale.max) * toScale.max;
            if (toScale.min > toScale.max) {
                return invertScale(converted, toScale.max, toScale.min);
            }
            return converted;
        }

        function pov(from, to) {
            const angleRad = getAngle(from, to)

            let fov = 50;
            let step = .5
            let xStep = 800 / fov * step;
            let xPosition = 0;
            for (let degree = (fov / 2); degree >= -1 * (fov / 2); degree -= step) {
                let radians = degree * Math.PI / 180;

                const {
                    distance,
                    oneUnitInX,
                    oneUnitInY,
                    xDirection,
                    yDirection,
                    increments,
                    lastSideHit
                } = ray(from, angleRad - radians);

                const perpendicularDistance = distance * Math.cos(radians);
                const height = 600 / (perpendicularDistance);

                cameraCtx.fillStyle = lastSideHit == 0 ? 'white' : lastSideHit == 1 ? 'gray' : 'red';
                cameraCtx.fillRect(
                    xPosition,
                    300 - height / 2,
                    xStep,
                    height,
                );
                xPosition += xStep;
            }
        }

        draw();

    </script>
</body>

</html>